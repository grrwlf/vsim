#!/bin/sh

die() {
	echo "$@" >&2 ; exit 1 ;
}

comment() { return 0 ; }

cpto() {
	case $# in
		1) local to=$1 ;;
		*) die "usage: cpto DEST" ;;
	esac
	read -r from
	test -f "$from" || die "cpto: invalid source file read from stdin"
	cp "$from" "$to" && echo "$to"
}

xargs_() {
	local args=""
	while read -r a ; do args="$args $a" ; done
	"$@" $args
}

ospath() {
	case $OS in
		*indows*) cygpath -w "$1" ;;
		*) echo $1 ;;
	esac
}

stime() {
	/usr/bin/time -f '%e' "$@"
}

vircheck() {
	comment "vircheck FILE.vhdl : Cnvert FILE.vhdl to FILE.vir and view it"
	local f=`mktemp`
	runtr "$@" | xargs_ dist/build/VirCheck/VirCheck > $f
	vim -c "set ft=haskell" `ospath $f`
}

gensim() {
	comment "gensim FILE.vhdl : Generate Haskell code for FILE.vhdl"
	runtr "$@" | xargs_ dist/build/VSim/VSim | tee src_r/Test/Autogen.hs
}


runtest() { (
	comment "runtest [-o LOGDIR] vhdl/FILE.vhd : Compile and run the test. Return the path to the LOGDIR"
	local tn=""
	local out=""
	while test -n "$1" ; do
		case "$1" in
			-o) out="$2"; shift;;
			*) tn="$1" ;;
		esac
		shift
	done

	if test -z "$out" ; then
		out=`mktemp -d`
	fi

	(
	if test -z "$tn" ; then
		die "TEST_NAME argument is required"
	fi

	VSIM=dist/build/VSim/VSim
	test -x "$VSIM" ||
		die "$VSIM is not an executable"
	
	TNAME=`basename $tn .vhd`
	echo $TNAME > $out/NAME

	TST=src_r/Test/$TNAME
	if test -f "$TST" ; then
		rm -rf "$TST" ||
			die "error: File $TST exists and I can't delete it"
	fi

	if test -f "$TST.hs" ; then
		rm -rf "$TST.hs" ||
			die "error: File $TST.hs exists and I can't delete it"
	fi

	date > $out/DATE
	( runtr "$tn" ; echo $? >&2 ; ) 2> $out/transl.log |
	( read -r x ; 
	  cat $x > $out/transl.vir ;
	  dist/build/VSim/VSim $x ;
	  echo $? >&2 ;
	) 2> $out/vsim.log |
	tee $TST.hs > $out/sim.hs

	GHC_SRC=`ospath $TST.hs`
	GHC_OUT=`ospath $TST`

	( stime -o $out/ghc.time \
		ghc --make -O2 -isrc_r "$GHC_SRC" -o $GHC_OUT 2>&1 ; echo $? ; ) | tee $out/ghc.log
	if ! test -x "$TST" ; then
		die "$TST is not an executable"
	fi

	( stime -o $out/binary.time $TST ; echo $? ; ) | tee $out/binary.log

	) 2>&1 | tee $out/script.log >&2

	echo $out
) }

catall() {
	while read d ; do
		(
		echo 
		echo "listing $d"
		echo "==========================="
		echo 

		cd $d || die "can't cd to $d"
		for f in `ls -1` ; do
			case $f in
				*log|*.hs|*.vir) echo "$f:" ; cat -n $f ;;
				*) echo non-log: "$f" ;;
			esac
		done
		)
	done
}

viewtr() {
	comment "viewtr FILE.vhdl : Generate FILE.vir and view it"
	local f=`runtr "$@"`&& vim $f -c "set ft=lisp"
}

runaldec() { (
	comment "runaldec FILE.vhd : Run the aldec simulator"

	CWD=`pwd`
	case $1 in
		/*vhd|/*vhdl) VHD=$1 ;;
		*vhd|*vhdl) VHD=$PWD/$1 ;;
		*) die "usage: runtr VHDL_FILE" ;;
	esac

	WORK=.aldec
	rm -rf $WORK >/dev/null 2>&1
	mkdir $WORK >/dev/null 2>&1
	cd $WORK ||
		die "can't cd into $WORK"

	ENTITY=`sed -n 's@entity \(.*\) is@\1@ p' $VHD | head -n 1`
	echo "Using entity name $ENTITY" >&2

	(
	echo vlib ieee
	echo vcom -work ieee `ospath $CWD/vhdl/IEEE/std_logic_1164.vhdl`

	echo vlib work
	echo set worklib work
	echo vcom -work work `ospath $VHD`

	echo vsim work.$ENTITY
	echo trace -verbose '*'
	echo run 9999ms
	) > './a.do'

	stime vsimsa '-do' 'a.do' ||
		die "Aldec reported error $?"
) }

aldecwave() {
	comment "aldecwave : view Aldec waveforms generated by the last call to runaldec"
	avhdl.exe .aldec/wave.asdb
}


runghdl() { (
	comment "runghdl FILE.vhdl : Run ghdl simulator"
	CWD=`pwd`
	case $1 in
		/*vhd|/*vhdl) VHD=$1 ;;
		*vhd|*vhdl) VHD=$PWD/$1 ;;
		*) die "usage: runtr VHDL_FILE" ;;
	esac

	WORK=.ghdl
	rm -rf $WORK >/dev/null 2>&1
	mkdir $WORK >/dev/null 2>&1
	cd $WORK ||
		die "can't cd into $WORK"

	cp $VHD file.vhd

	ENTITY=`sed -n 's@entity \(.*\) is@\1@ p' $VHD | head -n 1`
	echo "Using entity name $ENTITY" >&2

	ghdl -a file.vhd
	ghdl -r $ENTITY
) }

runtr() { (
	comment "runtr FILE.vhdl : run java translator"
	CWD=`pwd`
	case $1 in
		/*vhd|/*vhdl) VHD=$1 ;;
		*vhd|*vhdl) VHD=$PWD/$1 ;;
		*) die "usage: runtr VHDL_FILE" ;;
	esac

	JAVABIN=$CWD/tr/bin
	TRANSL=com.prosoft.vhdl.test.Test
	WORK=.transl
	VHDL=$CWD/vhdl

	rm -rf $WORK >/dev/null 2>&1
	mkdir $WORK >/dev/null 2>&1
	cd $WORK ||
		die "can't cd into $WORK"

	(
	echo STD
	ospath $VHDL/STD
	echo standard.vhd
	) >./standard.cfg

	(
	echo IEEE
	ospath $VHDL/IEEE
	echo std_logic_1164.vhdl
	echo numeric_bit.vhdl
	echo numeric_std.vhdl
	echo synopsys/std_logic_arith.vhdl
	echo synopsys/std_logic_misc.vhdl
	echo synopsys/std_logic_signed.vhdl
	echo synopsys/std_logic_unsigned.vhdl
	) >./ieee.cfg

	ENTITY=`sed -n 's@entity \(.*\) is@\1@ p' $VHD | head -n 1`
	echo "Using entity name $ENTITY" >&2

	VIRFILE=`mktemp --suffix .vir`
	java -cp `ospath $JAVABIN` \
		$TRANSL \
		--quiet \
		--no-symbols \
		standard.cfg \
		ieee.cfg \
		`ospath $VHD` \
		work.$ENTITY \
		`ospath $VIRFILE` >&2 ||
			die "translator failed"

	echo `ospath $VIRFILE`
) }

# Searches for VHDL test for a given manual chapter
ftest() { (
	cd vhdl_ct || die "Run from project root, please"
	local ch=`echo $1 | sed 's@\\.@\\\\\\.@g'`
	grep -e "--.* $ch" *vhd | awk -F : '{print $1}' | sort -u | xargs_ vim -p 
) }

countlines() {
	find $1 -name '*\.hs' |
		grep -v AST |
		grep -v Lexer |
		grep -v Paths_ |
		grep -v Test |
		grep -v CompareSignals.hs |
		xargs_ wc -l |
		tail -n 1 |
		awk '{print $1}'
}

linesofcode() {
	comment "linesofcode : Count the size of a project in lines of code"
	printf "runtime %s lines\n" `countlines src_r`
	printf "all     %s lines\n" `countlines .`
}

help() {
	declare -f | grep -v grep | sed -n 's@.*comment.*"\(.*\)".*@\1@g p' |
		awk -F ':' '{ printf("%-20s - %s\n",$1,$2);}'
}

if ! echo $0 | grep -q sh ; then (
	echo "simenv: You probably want to include this file insted of running it."
	echo "simenv: Type \`. simenv' in the shell prompt."
	) >&2
else
	echo "simenv: VSim runtime helper functions now enabled"
	echo "simenv: Type \`help' to view list of commands"
fi

